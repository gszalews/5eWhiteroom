# Dungeons & Dragons Encounter Analyzer
#### Video Demo: https://youtu.be/Gz7ob-e9np8
#### Description:
### Planning
        I had enjoyed the utility of learning to combine python and flask in the finance problem set and I felt that it would be useful to come up with a project that created a useful product at the end rather than just coding something for the sake of completing the course.  As a long time D&D player, I have been frustrated with the mechanics for creating encounters in the game - the system that the books provide is very generalized and doesn’t always provide a clear picture of how a “fight” in the game will play out. Other players as well as commentators on social media platforms like YouTube have had similar issues with the system, but their solutions to add detail require more time and the application of simple, but tedious math to figure out player average damage and monster hit point pools. As I thought of what to do for the project, I figured I could do something that would help streamline these calculations and make it faster and easier to plan successful encounters.
        At that point I began researching what online resources were available for working specifically with Dungeons and Dragons content. I discovered the Open5e API project, where I can have online access to monster statistics as well as spell and weapon information. Thus was born the Encounter Analyzer, a web app that allows players and game masters to input information for players and get a more detailed idea of how the encounter may play out in terms of its difficulty.
### Initial Decisions
        The choice to use flask and python was straightforward and easy, it was what I had learned from the course. In finance, however, we had used an SQL database - and while that would be a great fit for storing the data and allowing users to save their characters and encounters, it would require a login. I think there is some “login fatigue” and that a free tool that you would need to “sign up” to use would be a roadblock to adoption. If, instead, users could just get started with the web app right away and not need to sign up / sign in then it stands a better chance of getting used. I was inspired by a site that allows for custom monster creation - you navigate to the page, create your monster, and you can then print off or download the monster file to be loaded again later. If you are visiting the page recently your information is still saved in the cookies.
        For my encounter analyzer web app the idea was to employ server side sessions to store the data and allow users to download files based on what they wanted to save: the party of players, the list of enemies, or the whole encounter (both players and enemies). Users can ask friends to visit the app, create their character, and email the file which can be added to others to build the party without the game master needing to create each character from their own memory or notes.
        I also needed to figure out the scope of the project and what analysis I would be able to accomplish. The API made some tasks easy by providing action information in JSON format that could easily be computed. Other information in the JSON, however, was not parsed but still in the sentence descriptions used within the game rule books. Luckily, the text follows a very fixed structure and I could build a function to parse the text and determine, for example, how many attacks a creature made and which actions it used during this “multiattack”. One area that could use further attention in the future is the monster “special abilities” which is also still in written description form but doesn’t have the same rigid structure. I haven’t come up with a solution to be able to parse these statements accurately enough to integrate them into the action economy.
### Structure
#### app.py
        The app program manages all of the flask routes and form interaction with the website. There is a landing page, a party creation page, an enemies page, and a save / load page as the main user areas of the site. Besides the index.html landing page, all of the pages make use of forms to gather user input and act.
        There are also other routes to add and remove monsters, remove members of the users party, and a more speicialized interface to edit a previously created character. This required a new 'editpc.html' page because it allowed me to fill out the form fields from the stored session JSON data. The submit button on the editpc page follows to the same route as the one on the standard party page.
        The app uses sessions to store data since I am not using a database to avoid users needing a login.
#### helpers.py
        This file contains all of the helper functions that the app uses to process and format the data and input gathered from the user. The api calls and the processing of the JSON into actionable information to build the enemies list, to gather and process spell data, to process the created characters and obtain their relevant statistics as well as those of the enemies - all of that is done in the helper.py file.
#### Layout - layout.html
        The layout page contains the nav-bar code and the background image for the app to have behind each page. The nav-bar was developed using a tutorial by fireship (https://youtu.be/biOMz4puGt8) where I went through the video multiple times to code it myself and understand how all of the css worked. Because I hope to release the site to others, I wanted to have a slick ux that maintained simplicity but demonstrated style and polish. Being able to create such a nav-bar for my own site was very helpful but it did take me a number of hours to implement correctly and in a way that I felt comfortable saying that I had learned the material and could continue to adjust the code, icons, etc. to meet my needs.
#### Landing Page - index.html
        The landing page for the website provide a few paragraphs of introduction to help users understand why the app exists, what the app is designed to to, and what it is not going to do. There are many different approaches that people have taken for online encounter creation and I want users to have access to information helping them decide if this tool is right for them. When creating the landing page I made the choice about the overall style of the website. One early choice was the fonts, which mimic those found in the official game documentation to help the app feel authentic to users. The color scheme I came up with using Coolors.co based on the idea of a blue, burgundy, and gold idea. I had found some free icons available for each character class that I planned to use and I made the blue and gold color that they used the anchor parts of the scheme, later tweaking a red down into a deeper tone and a cream color to balance out that depth and compliment the blue and gold. I found a free vector graphic of the hydra that is used as the subtle background image. It took me a long time to figure out how to appropriately place that in the background with the CSS. Eventually I was able to use the basic “background-image” framework, but initially that hadn’t been effective due to the structure of divs etc. across all of the pages. I had tried to make a div just for the background, but it kept getting pushed around by everything else and using position “absolute” also created issues with placement.
#### Party Creation - party.html / editpc.html
        The page for creating the party is a form that uses javascript to streamline what appears on the screen for data input. I didn’t want every option to “appear” all at once to the user and overwhelm them with details that may not be important for their character, so I made sure that most of the fields that provide a depth of detail regarding specific character classes were hidden until activated with toggles. I also made almost the entire form out of select boxes to help control user input and reduce erroneous mistakes. Only a few fields are “required” so that users who want to focus only on the specifics of their character can do so. A wizard, for example, doesn’t need to input a weapon attack because as a rule, they aren’t using their weapon attack unless something has gone horribly wrong in the game. This allows the user to help control the level of detail in character creation and eases the “burden” of having to input every detail of a character in order to get results - the user inputs what they think is important.
        It was important to visually confirm which party members had been added, so similar to the finance problem where we displayed the “portfolio” of holdings, I set up the party page to display characters that had already been added to the party along with some of their relevant information. I created buttons to edit the characters to make sure that users didn’t need to “start over” every time they wanted to change a character attribute or correct an error. I also created a path for characters to be removed from the list as well. Next to each character’s average damage is an icon to deploy a modal that will show the math behind the calculations that are being done to give users a way to verify that the site is meeting their expectations and help them understand, if they wish, what is going on “under the hood”. I felt it was important to provide this information to make the tool trustworthy to users and increase confidence in its use.
        Above the individual party members there is also a table displaying the group information that is used for the analyzer, so users can see how any new addition to the party affects the averaged statistics of the group. For the group statistics I used straight averages for saving throws since effects like spells or breath weapons from monsters often affect the party widely. For the Armor Class average, I used a weighted average based on character class, since a majority of the time it is “melee” characters that bear the brunt of such attacks. Currently, the weights spread from 100% for martial classes down to 40% for full magic users with stops along the way for different classes that blend melee attacks with more range-favoring spells.


#### Enemy Selection - enemies.html
        The enemies list is drawn from a text file so that I do not have to make a large API call for every monster name each time the page loads. I have a secondary script (download_enemy_names.py) that can run to generate the name file which can be programmed to run each day, etc. to update the list if the API information has changed. The enemies page simply allows the user to choose an enemy from a select box as well as the number of those enemies to add to the encounter. A “count” variable keeps track of how many enemies of a certain type there are so that multiple API calls don’t need to be made to get information about the same enemy.
        Similarly to the party page, the enemies page displays a list of the current enemies with their relevant statistics and allows for their number to be increased or decreased easily with a button click. The group statistics above the individual enemy table are similar to those seen on the party page, but where character class is used as a weight occasionally for that information the enemies statistics are almost universally weighted by hit points to help accurately depict an average score needed to cause damage via weapons or spells.


#### Encounter Description - encounter.html
        The encounter page combines the displays of the party and enemy lists and uses modals to display the individual lists seen on the respective focus pages (party / enemies). The main feature of the page is a simple bar graph that is generated using jinja and css styled divs to display the total hit points for the party and the enemies as well as bars for each side’s damage output. The displayed party damage can be changed with three different javascript buttons that allow users to see low, medium, and high damage output estimates. The purpose of this is to be able to get a feel for how the fight would be different if the party were low on resources (low damage), used some of their abilities and skill resources (med), or were fighting the battle with full resources and no plan to conserve those resources (high).


#### Save / Load - files.html
        The input and output pages allow users to save their work by writing a JSON file of the data for whatever part of the encounter they wish to save. This allows users to create a character and send it to a game master, a game master to create a save a group of enemies to be used later once characters have been created, or to save an entire encounter of both the party and the enemies.
        Loaded files are not stored on the server to save space and keep maintenance simple. They are loaded into the app and the file is discarded after being read. It appends all of the monsters and party members into their respective groups based on the file extension that was used.